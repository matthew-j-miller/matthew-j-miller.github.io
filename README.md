### Matt's Website

## Homework 4

This chapter of the Pragmatic Programmer is titled "A Pragmatic Approach." Instead of focusing on the large overarching themes of 
software engineering, this chapter focuses on a few specific rules to define how code should be designed and developed. The chapter 
begins by introducing the importance of preventing duplication and ensuring that one's program's are "orthogonal." Preventing 
duplication is vital to clean code, as when code needs to be maintained, it can be harder to to so if you have to comb through all 
existing code to find variants of one variable. Orthogonality refers to keeping code from being to interdependent. When code becomes to 
interdependent, serious problems arise when modifications have to be made. Blocks of code need to be well-organized, well-named, and 
limited in scope so that changes to one part of the code do not negatively impact other parts of the software. The chapter then talks 
about reversability, and how to prevent code from being made obselete by changing conditions. 

The most important topic in this chapter, to me, was the concept of Tracer Bulllets. In that section, the author pointed out how 
projects can get slowed in the process of determining every single problem they expect to encounter, and wasting time building prototype 
after protoypes when they could be implementing actual solutions. This style of development really appealed to me, in how it allowed 
both the fleshing out of concepts, and the creation of useful code at the same time. 

## Homework 3

This chapter can be boiled down to a few key concepts: first, be a responsible programmer by owning up to mistakes, maintaining code 
cleanliness, and working as a member of a team; second, make a serious effort to keep your skills and knowledge up to date; and third, 
learn how to communicate your ideas, especially with those who lack the technical skills you have. This book surprised me in that it 
didn't lead with some overarching concept about how code should look, instead it focused on what a coder should do, and seems to suggest 
that good code will come from behavior, not a strict set of rules. I agree with most of the themes of the chapter, but some of its 
suggestions go a bit far, particularly when they suggest that you should learn an entire new language once a year. While I suppose I 
have been doing more than that for the past two years, that’s still a lot of effort for what doesn’t seem like it would be too much 
payoff, but perhaps I underestimate how many languages are in common use. The style of the book surprised me, with how casual and non-
technical the language was, and not at all what I had expected from a programming textbook. 

## Writing Assignment 2:
Why are you taking this class?

In all honesty, the primary reason I'm taking this class is to complete my minor and because I thought, correctly, that it would be a 
challenging course. I also am taking it because I wanted to really see how the programming of complex pieces of software takes place. I 
don't really have plans to go into computer science beyond this class, but I want to at least be able to understand how the magic 
happens. 
After the completion of this course, I really just want to have a fundamental understanding of how software is created, operates, and 
interacts with other pieces of code.

## Writing Assignment 1:
What Software Engineering Means to Me

Up until recently, the phrase software engineering had always been a sort of vague and mildly intimidating idea of something that only 
professionals who had spent years in the field were capable of doing. However, after the work I struggled through last semester, the 
phrase has lost its edge, and it has come simply to mean writing code and utilizing it in an organized way to accomplish a task. 
Obviously, there is more to the discipline than that, and I have plenty more to learn, but the class I took before this I think has 
prepared me. 















